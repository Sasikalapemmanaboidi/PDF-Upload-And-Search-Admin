-- MySQL dump 10.13  Distrib 8.0.32, for Win64 (x86_64)
--
-- Host: localhost    Database: pdf_processor
-- ------------------------------------------------------
-- Server version	8.0.32

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `pdf_page`
--

DROP TABLE IF EXISTS `pdf_page`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `pdf_page` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `page_number` int unsigned NOT NULL,
  `text` longtext NOT NULL,
  `document_id` bigint NOT NULL,
  PRIMARY KEY (`id`),
  KEY `pdf_page_document_id_87eb2426_fk_pdf_document_id` (`document_id`),
  CONSTRAINT `pdf_page_document_id_87eb2426_fk_pdf_document_id` FOREIGN KEY (`document_id`) REFERENCES `pdf_document` (`id`),
  CONSTRAINT `pdf_page_chk_1` CHECK ((`page_number` >= 0))
) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `pdf_page`
--

LOCK TABLES `pdf_page` WRITE;
/*!40000 ALTER TABLE `pdf_page` DISABLE KEYS */;
INSERT INTO `pdf_page` VALUES (1,1,'In this Chapter\n»»\nIntroduction\n»»\nSyntax Errors\n»»\nExceptions\n»»\nBuilt-in Exceptions\n»»\nRaising Exceptions\n»»\nHandling Exceptions\n»»\nFinally Clause\nC\nh\na\np\nt\ne\nr\n“I like my code to be elegant and efficient. The logic \nshould be straightforward to make it hard for bugs to hide, \nthe dependencies minimal to ease maintenance, error handling \ncomplete according to an articulated strategy, and performance \nclose to optimal so as not to tempt people to make the code messy \nwith unprincipled optimization. Clean code does one thing well.” \n— Bjarne Stroustrup\n1.1 Introduction\nSometimes while executing a Python program, the \nprogram does not execute at all or the program \nexecutes but generates unexpected output or \nbehaves abnormally. These occur when there are \nsyntax errors, runtime errors or logical errors in \nthe code. In Python, exceptions are errors that \nget triggered automatically. However, exceptions \ncan be forcefully triggered and handled through \nprogram code. In this chapter, we will learn about \nexception handling in Python programs.\n1.2 Syntax Errors\nSyntax errors are detected when we have not \nfollowed the rules of the particular programming \nlanguage while writing a program. These errors are \nalso known as parsing errors. On encountering a \nsyntax error, the interpreter does not execute the \nprogram unless we rectify the errors, save and \n1 \nException Handling \nin Python\nReprint 2025-26\n',1),(2,2,'Computer Science - Class XII\n2\nrerun the program. When a syntax error is encountered \nwhile working in shell mode, Python displays the name \nof the error and a small description about the error as \nshown in Figure 1.1.\nSo, a syntax error is reported by the Python \ninterpreter giving a brief explanation about the error \nand a suggestion to rectify it. \nSimilarly, when a syntax error is encountered while \nrunning a program in script mode as shown in Figure \n1.2, a dialog box specifying the name of the error (Figure \n1.3) and a small description about the error is displayed. \nFigure 1.2:	 An error in the script \nFigure 1.3:	 Error dialog box\n \nFigure 1.1:	 A syntax error displayed in Python shell mode\nReprint 2025-26\n',1),(3,3,'Exception Handling in Python\n3\n1.3 Exceptions\nEven if a statement or expression is syntactically \ncorrect, there might arise an error during its execution. \nFor example, trying to open a file that does not exist, \ndivision by zero and so on. Such types of errors might \ndisrupt the normal execution of the program and are \ncalled exceptions.\nAn exception is a Python object that represents an \nerror. When an error occurs during the execution of a \nprogram, an exception is said to have been raised. Such \nan exception needs to be handled by the programmer \nso that the program does not terminate abnormally. \nTherefore, while designing a program, a programmer \nmay anticipate such erroneous situations that may arise \nduring its execution and can address them by including \nappropriate code to handle that exception.\nIt is to be noted that SyntaxError shown at Figures \n1.1 and 1.3 is also an exception. But, all other exceptions \nare generated when a program is syntactically correct. \n1.4 Built-in Exceptions\nCommonly occurring exceptions are usually defined \nin the compiler/interpreter. These are called built-in \nexceptions. \nPython’s standard library is an extensive collection \nof built-in exceptions that deals with the commonly \noccurring \nerrors \n(exceptions) \nby \nproviding \nthe \nstandardized solutions for such errors. On the occurrence \nof any built-in exception, the appropriate exception \nhandler code is executed which displays the reason \nalong with the raised exception name. The programmer \nthen has to take appropriate action to handle it. Some \nof the commonly occurring built-in exceptions that can \nbe raised in Python are explained in Table 1.1.\nTable 1.1	 Built-in exceptions in Python\nS. No\nName of the Built-\nin Exception\nExplanation\n1.\nSyntaxError \nIt is raised when there is an error in the syntax of the Python code.\n2. \nValueError\nIt is raised when a built-in method or operation receives an argument \nthat has the right data type but mismatched or inappropriate values.\n3.\nIOError\nIt is raised when the file specified in a program statement cannot be \nopened.\nReprint 2025-26\n',1),(4,4,'Computer Science - Class XII\n4\n4\nKeyboardInterrupt\nIt is raised when the user accidentally hits the Delete or Esc key \nwhile executing a program due to which the normal flow of the \nprogram is interrupted.\n5\nImportError\nIt is raised when the requested module definition is not found.\n6\nEOFError\nIt is raised when the end of file condition is reached without reading \nany data by input().\n7\nZeroDivisionError\nIt is raised when the denominator in a division operation is zero.\n8\nIndexError\nIt is raised when the index or subscript in a sequence is out of range.\n9\nNameError\nIt is raised when a local or global variable name is not defined.\n10\nIndentationError\nIt is raised due to incorrect indentation in the program code.\n11\nTypeError\nIt is raised when an operator is supplied with a value of incorrect \ndata type.\n12\nOverFlowError\nIt is raised when the result of a calculation exceeds the maximum \nlimit for numeric data type.\nFigure \n1.4 \nshows \nthe \nbuilt-in \nexceptions \nviz, \nZeroDivisionError, NameEError, and TypeError raised \nby the Python interpreter in different situations.\n \nFigure 1.4:	 Example of built-in exceptions\nA programmer can also create custom exceptions to \nsuit one’s requirements. These are called user-defined \nexceptions. We will learn how to handle exceptions in \nthe next section. \n1.5 Raising Exceptions\nEach time an error is detected in a program, the Python \ninterpreter raises (throws) an exception. Exception \nReprint 2025-26\n',1),(5,5,'Exception Handling in Python\n5\nhandlers are designed to execute when a specific \nexception is raised. Programmers can also forcefully \nraise exceptions in a program using the raise and assert \nstatements. Once an exception is raised, no further \nstatement in the current block of code is executed. So, \nraising an exception involves interrupting the normal \nflow execution of program and jumping to that part of \nthe program (exception handler code) which is written \nto handle such exceptional situations.\n1.5.1 The raise Statement\nThe raise statement can be used to throw an exception. \nThe syntax of raise statement is:\nraise exception-name[(optional argument)]\nThe argument is generally a string that is displayed \nwhen the exception is raised. For example, when an \nexception is raised as shown in Figure 1.5, the message \n“OOPS : An Exception has occurred” is displayed along \nwith a brief description of the error.\nFigure 1.5:	 Use of the raise statement to throw an exception\nThe error detected may be a built-in exception or \nmay be a user-defined one. Consider the example given \nin Figure 1.6 that uses the raise statement to raise a \nbuilt-in exception called IndexError.\nNote: In this case, the user has only raised the exception but \nhas not displayed any error message explicitly. \nIn Figure 1.6, since the value of variable length \nis greater than the length of the list numbers, an \nIndexError exception will be raised. The statement \nfollowing the raise statement will not be executed. So \nthe message “NO EXECUTION” will not be displayed in \nthis case.\nReprint 2025-26\n',1),(6,6,'Computer Science - Class XII\n6\nAs we can see in Figure 1.6, in addition to the \nerror message displayed, Python also displays a stack \nTraceback. This is a structured block of text that \ncontains information about the sequence of function \ncalls that have been made in the branch of execution of \ncode in which the exception was raised. In Figure 1.6, \nthe error has been encountered in the most recently \ncalled function that has been executed.\n \n \nFigure 1.6:	 Use of raise statement with built-in exception\nProgram 1-1	\nUse of assert statement\nprint(\"use of assert statement\")\ndef negativecheck(number):\n    assert(number>=0), \"OOPS... Negative Number\"\nNote: We will learn about Stack in Chapter 3.\n1.5.2 The assert Statement\nAn assert statement in Python is used to test an \nexpression in the program code. If the result after testing \ncomes false, then the exception is raised. This statement \nis generally used in the beginning of the function or after \na function call to check for valid input. The syntax for \nassert statement is:\n      	\nassert Expression[,arguments]\nOn encountering an assert statement, Python \nevaluates the expression given immediately after \nthe assert keyword. If this expression is false, an \nAssertionError exception is raised which can be handled \nlike any other exception. Consider the code given in \nProgram 1-1.   \nReprint 2025-26\n',1),(7,7,'Exception Handling in Python\n7\n    print(number*number)\nprint (negativecheck(100))\nprint (negativecheck(-350))\nFigure 1.7:	  Output of Program 1-1. \nIn the code, the assert statement checks for the \nvalue of the variable number. In case the number gets \na negative value, AssertionError will be thrown, and \nsubsequent statements will not be executed. Hence, \non passing a negative value (-350) as an argument, it \nresults in AssertionError and displays the message \n“OOPS…. Negative Number”. The output of the code is \nshown in Figure 1.7.\n1.6 Handling Exceptions\nEach and every exception has to be handled by the \nprogrammer to avoid the program from crashing \nabruptly. This is done by writing additional code in \na program to give proper messages or instructions to \nthe user on encountering an exception. This process is \nknown as exception handling. \n1.6.1 Need for Exception Handling\nException handling is being used not only in Python \nprogramming but in most programming languages like \nC++, Java, Ruby, etc. It is a useful technique that helps \nin capturing runtime errors and handling them so as to \navoid the program getting crashed. Following are some \nReprint 2025-26\n',1),(8,8,'Computer Science - Class XII\n8\nof the important points regarding exceptions and their \nhandling:\n•	 Python categorises exceptions into distinct types so \nthat specific exception handlers (code to handle that \nparticular exception) can be created for each type.\n•	 Exception handlers separate the main logic of the \nprogram from the error detection and correction \ncode. The segment of code where there is any \npossibility of error or exception, is placed inside one \nblock. The code to be executed in case the exception \nhas occurred, is placed inside another block. These \nstatements for detection and reporting the exception \ndo not affect the main logic of the program.\n•	 The compiler or interpreter keeps track of the exact \nposition where the error has occurred.\n•	 Exception handling can be done for both user-defined \nand built-in exceptions.\n1.6.2 Process of Handling Exception\nWhen an error occurs, Python interpreter creates an \nobject called the exception object. This object contains \ninformation about the error like its type, file name and \nposition in the program where the error has occurred. \nThe object is handed over to the runtime system so that \nit can find an appropriate code to handle this particular \nexception. This process of creating an exception object \nand handing it over to the runtime system is called \nthrowing an exception. It is important to note that \nwhen an exception occurs while executing a particular \nprogram statement, the control jumps to an exception \nhandler, abandoning execution of the remaining \nprogram statements.\nThe runtime system searches the entire program \nfor a block of code, called the exception handler that \ncan handle the raised exception. It first searches for \nthe method in which the error has occurred and the \nexception has been raised. If not found, then it searches \nthe method from which this method (in which exception \nwas raised) was called. This hierarchical search in \nreverse order continues till the exception handler is \nfound. This entire list of methods is known as call stack. \nWhen a suitable handler is found in the call stack, it \nis executed by the runtime process. This process of \nA runtime system \nrefers to the \nexecution of the \nstatements given in \nthe program. It is a \ncomplex mechanism \nconsisting of \nhardware and \nsoftware that \ncomes into action \nas soon as the \nprogram, written in \nany programming \nlanguage, is put for \nexecution.\nReprint 2025-26\n',1),(9,9,'Exception Handling in Python\n9\nexecuting a suitable handler is known as catching the \nexception. If the runtime system is not able to find an \nappropriate exception after searching all the methods in \nthe call stack, then the program execution stops.\nThe flowchart in Figure 1.8 describes the exception \nhandling process.\n \nFigure 1.8:	 Steps of handling exception\n1.6.3 Catching Exceptions\nAn exception is said to be caught when a code that is \ndesigned to handle a particular exception is executed. \nExceptions, if any, are caught in the try block and \nReprint 2025-26\n',1),(10,10,'Computer Science - Class XII\n10\nhandled in the except block. While writing or debugging \na program, a user might doubt an exception to occur \nin a particular part of the code. Such suspicious \nlines of codes are put inside a try block. Every try \nblock is followed by an except block. The appropriate \ncode to handle each of the possible exceptions (in \nthe code inside the try block) are written inside the \nexcept clause. \nWhile executing the program, if an exception is \nencountered, further execution of the code inside the \ntry block is stopped and the control is transferred to \nthe except block. The syntax of try … except clause \nis as follows:\n	\ntry:\n[ program statements where exceptions might occur]\nexcept [exception-name]:\n[ code for exception handling if the exception-name error is \nencountered]\nConsider the Program 1-2 given below:\nProgram 1-2 	 Using try..except block\nprint (\"Practicing for try block\")\ntry:\n    numerator=50\n    denom=int(input(\"Enter the denominator\"))\n    quotient=(numerator/denom)\n    print(quotient)\n    print (\"Division performed successfully\")\nexcept ZeroDivisionError:\n    print (\"Denominator as ZERO.... not allowed\")\nprint(“OUTSIDE try..except block”)\nIn Program 1-2, the ZeroDivisionError exception \nis handled. If the user enters any non-zero value as \ndenominator, the quotient will be displayed along with \nthe message “Division performed successfully”, as \nshown in Figure 1.10. The except clause will be skipped \nin this case. So, the next statement after the try..except \nblock is executed and the message “OUTSIDE try..\nexcept block” is displayed.\nHowever, if the user enters the value of denom as \nzero (0), then the execution of the try block will stop. \nThe control will shift to the except block and the \nmessage “Denominator as Zero…. not allowed” will \nbe displayed, as shown in Figure 1.11. Thereafter, the \nReprint 2025-26\n',1),(11,11,'Exception Handling in Python\n11\nstatement following the try..except block is executed \nand the message “OUTSIDE try..except block” is \ndisplayed in this case also.\nSometimes, a single piece of code might be suspected \nto have more than one type of error. For handling such \nsituations, we can have multiple except blocks for a \nsingle try block as shown in the Program 1-3.\nProgram 1-3 	 Use of multiple except clauses\nprint (\"Handling multiple exceptions\")\ntry:\n    numerator=50\n    denom=int(input(\"Enter the denominator: \"))\n    print (numerator/denom)\n    print (\"Division performed successfully\")\nexcept ZeroDivisionError:\n    print (\"Denominator as ZERO is not allowed\")\nexcept ValueError:\n    print (\"Only INTEGERS should be entered\")\nFigure 1.9:	 Output without an error   \nFigure 1.10:	Output with exception raised\nReprint 2025-26\n',1),(12,12,'Computer Science - Class XII\n12\nIn the code, two types of exceptions (ZeroDivisionError \nand ValueError) are handled using two except blocks \nfor a single try block. When an exception is raised, \na search for the matching except block is made till \nit is handled. If no match is found, then the program \nterminates.\nHowever, if an exception is raised for which no \nhandler is created by the programmer, then such an \nexception can be handled by adding an except clause \nwithout specifying any exception. This except clause \nshould be added as the last clause of the try..except \nblock. The Program 1-4 given below along with the \noutput given in Figure 1.11 explains this.\nProgram 1-4	\nUse of except without specifying an exception\nprint (\"Handling exceptions without naming them\")\ntry:\n    numerator=50\n    denom=int(input(\"Enter the denominator\"))\n    quotient=(numerator/denom)\n    print (\"Division performed successfully\")\nexcept ValueError:\n    print (\"Only INTEGERS should be entered\")\nexcept:\n    print(\" OOPS.....SOME EXCEPTION RAISED\")\nFigure 1.11:	Output of Program 1-4\n1.6.4 try...except…else clause\nWe can put an optional else clause along with the \ntry...except clause. An except block will be executed \nIf the above code is executed, and the denominator \nentered is 0 (zero) , the handler for ZeroDivisionError \nexception will be searched. Since it is not present, the \nlast except clause (without any specified exception) \nwill be executed , so the message “ OOPS.....SOME \nEXCEPTION RAISED” will be displayed.\nReprint 2025-26\n',1),(13,13,'Exception Handling in Python\n13\nProgram 1-5	\nUse of else clause\nprint (\"Handling exception using try...except...else\")\ntry:\n    numerator=50\n    denom=int(input(\"Enter the denominator: \"))\n    quotient=(numerator/denom)\n    print (\"Division performed successfully\")\nexcept ZeroDivisionError:\n    print (\"Denominator as ZERO is not allowed\")\nexcept ValueError:\n    print (\"Only INTEGERS should be entered\")\nelse:\n   print (\"The result of division operation is \", quotient)\n \nOutput:\nFigure 1.12:	 Output of Program 1-5.\n1.7 Finally Clause\nThe try statement in Python can also have an optional \nfinally clause. The statements inside the finally block \nare always executed regardless of whether an exception \nhas occurred in the try block or not. It is a common \npractice to use finally clause while working with files \nto ensure that the file object is closed. If used, finally \nshould always be placed at the end of try clause, after \nall except blocks and the else block.\nonly if some exception is raised in the try block. But if \nthere is no error then none of the except blocks will \nbe executed. In this case, the statements inside the \nelse clause will be executed. Program 1-5 along with \nits output explains the use of else block with the try...\nexcept block.  \nReprint 2025-26\n',1),(14,14,'Computer Science - Class XII\n14\nProgram 1-6	\nUse of finally clause\nprint (\"Handling exception using try...except...else...finally\")\ntry:\n	 numerator=50\n	 denom=int(input(\"Enter the denominator: \"))\n	 quotient=(numerator/denom)\n	 print (\"Division performed successfully\")\nexcept ZeroDivisionError:\n	 print (\"Denominator as ZERO is not allowed\")\nexcept ValueError:\n	 print (\"Only INTEGERS should be entered\")\nelse:\n	 print (\"The result of division operation is \", quotient)\nfinally:\n	 print (\"OVER AND OUT\") \nProgram 1-7	\nRecovering through finally clause\nprint (\" Practicing for try block\")\ntry:\n	 numerator=50\n	 denom=int(input(\"Enter the denominator\"))\n	 quotient=(numerator/denom)\n	 print (\"Division performed successfully\")\nexcept ZeroDivisionError:\n	 print (\"Denominator as ZERO is not allowed\")\nelse:\n	 print (\"The result of division operation is \", quotient)\nfinally:\n	 print (\"OVER AND OUT\")\nIn the above program, the message “OVER AND OUT” \nwill be displayed irrespective of whether an exception is \nraised or not.\n1.6.1 Recovering and continuing with finally clause\nIf an error has been detected in the try block and the \nexception has been thrown, the appropriate except \nblock will be executed to handle the error. But if the \nexception is not handled by any of the except clauses, \nthen it is re-raised after the execution of the finally \nblock. For example, Program 1.4 contains only the \nexcept block for ZeroDivisionError. If any other \ntype of error occurs for which there is no handler code \n(except clause) defined, then also the finally clause will \nbe executed first. Consider the code given in Program \n1-7 to understand these concepts.\nReprint 2025-26\n',1),(15,15,'Exception Handling in Python\n15\nWhile executing the above code, if we enter a \nnon-numeric data as input, the finally block will be \nexecuted. So, the message “OVER AND OUT” will be \ndisplayed. Thereafter the exception for which handler is \nnot present will be re-raised. The output of Program 1-7 \nis shown in Figure 1.13.\nFigure 1.13:	Output of Program 1-7\nAfter execution of finally block, Python transfers \nthe control to a previously entered try or to the next \nhigher level default exception handler. In such a case, \nthe statements following the finally block is executed. \nThat is, unlike except, execution of the finally clause \ndoes not terminate the exception. Rather, the exception \ncontinues to be raised after execution of finally.\nTo summarise, we put a piece of code where there \nare possibilities of errors or exceptions to occur inside \na try block. Inside each except clause we define handler \ncodes to handle the matching exception raised in the \ntry block. The optional else clause contains codes to \nbe executed if no exception occurs. The optional finally \nblock contains codes to be executed irrespective of \nwhether an exception occurs or not.\nSummary\n•	 Syntax errors or parsing errors are detected when \nwe have not followed the rules of the particular \nprogramming language while writing a program. \nReprint 2025-26\n',1),(16,16,'Computer Science - Class XII\n16\n•	 When syntax error is encountered, Python displays \nthe name of the error and a small description \nabout the error.\n•	 The execution of the program will start only after \nthe syntax error is rectified.\n•	 An exception is a Python object that represents \nan error.\n•	 Syntax errors are also handled as exceptions.\n•	 The exception needs to be handled by the \nprogrammer so that the program does not \nterminate abruptly.\n•	 When an exception occurs during execution \nof a program and there is a built-in exception \ndefined for that, the error message written in that \nexception is displayed. The programmer then has \nto take appropriate action and handle it. \n•	 Some \nof \nthe \ncommonly \noccurring \nbuilt-in \nexceptions are SyntaxError, \nValueError, \nIOError, KeyboardInterrupt, ImportError, \nEOFError, ZeroDivisionError, IndexError, \nNameError, IndentationError, TypeError,and \nOverFlowerror.\n•	 When an error is encountered in a program, \nPython interpreter raises or throws an exception.\n•	 Exception Handlers are the codes that are \ndesigned to execute when a specific exception \nis raised. \n•	 Raising an exception involves interrupting the \nnormal flow of the program execution and jumping \nto the exception handler.\n•	 Raise and assert statements are used to raise \nexceptions.\n•	 The process of exception handling involves \nwriting additional code to give proper messages \nor instructions to the user. This prevents the \nprogram from crashing abruptly. The additional \ncode is known as an exception handler.\n•	 An exception is said to be caught when a code \nthat is designed to handle a particular exception \nis executed. \n•	 An exception is caught in the try block and \nhandles in except block.\nNotes\nReprint 2025-26\n',1),(17,17,'Exception Handling in Python\n17\nExercise\n1.	 “Every syntax error is an exception but every exception \ncannot be a syntax error.” Justify the statement.\n2.	 When are the following built-in exceptions raised? Give \nexamples to support your answers.\na)	 ImportError\nb)	 IOError\nc)	 NameError\nd)	 ZeroDivisionError\n3.	 What is the use of a raise statement? Write a code to \naccept two numbers and display the quotient. Appropriate \nexception should be raised if the user enters the second \nnumber (denominator) as zero (0).\n4.	 Use assert statement in Question No. 3 to test the \ndivision expression in the program.\n5.	 Define the following:\na)	 Exception Handling\nb)	 Throwing an exception\nc)	 Catching an exception\n6.	 Explain catching exceptions using try and except block.\n7.	 Consider the code given below and fill in the blanks.\nprint (\" Learning Exceptions...\")\ntry:\n    num1= int(input (\"Enter the first number\"))\n    num2=int(input(\"Enter the second number\"))\n    quotient=(num1/num2)\n    print (\"Both the numbers entered were correct\")\nexcept _____________:             # to enter only integers\n    print (\" Please enter only numbers\")\nexcept ____________:      # Denominator should not be zero\n    print(\" Number 2 should not be zero\")\nelse:\n    print(\" Great .. you are a good programmer\")\n___________:               # to be executed at the end\n    print(\" JOB OVER... GO GET SOME REST\")\n•	 The statements inside the finally block are always \nexecuted regardless of whether an exception \noccurred in the try block or not.\nReprint 2025-26\n',1),(18,18,'Computer Science - Class XII\n18\n8.	 You have learnt how to use math module in Class \nXI. Write a code where you use the wrong number of \narguments for a method (say sqrt() or pow()). Use the \nexception handling process to catch the ValueError \nexception.\n9.	 What is the use of finally clause? Use finally clause in \nthe problem given in Question No. 7.\nNotes\nReprint 2025-26\n',1);
/*!40000 ALTER TABLE `pdf_page` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2025-12-14 23:04:11
